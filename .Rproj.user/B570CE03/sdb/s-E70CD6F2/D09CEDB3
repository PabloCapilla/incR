{
    "contents" : "#' @title Calculation of incubation behaviour.\n#' @description This is the core algorithm of incR and classifies time points as 1s or 0s depeding on\n#' whether or not the incubating individual is estimated to be on the eggs. \n#' The algorithm\n#' uses night variation to calibrate itself to temperature variation when the incubating\n#' individual is (assumed to be) on the eggs. \n#' Therefore, a major assumption of this algorithm is that\n#' there is a period of time in which temperature can be assumed to be constant or\n#' representative of time windows of effective incubation. This time window is defined by\n#' two arguments: lower.time and upper.time. The function is optimised to work using\n#' a data frame produced by incR_prep.\n#' \n#' The algorithm can be adapted to different environmental circunstances. Its\n#' performance has been evaluated in several species and geographic areas, but calibration\n#' using pilot data is recommended. \n#' @param data: ny\n#' @param lower.time: ny\n#' @param upper.time: ny\n#' @param env.data: ny\n#' @param sensitivity: ny\n#' @param time.dif: ny\n#' @param MAX.T: ny\n#' @param maxNightVar_accepted: ny\n#' \n#' @return \n#' \n#' @examples\n#' \n#' @seealso \\code{\\link{incR_prep}}\n\n\nincR_scan <- function (data=data, \n                       lower.time=22,\n                       upper.time=3,\n                       env.data=FALSE,\n                       sensitivity=0.15,\n                       time.dif=20,\n                       MAX.T=38,\n                       maxNightVar_accepted=2) {\n  # NEW INTERNAL VECTORS\n  # \n  # big list to store the final vector of female position (in or out the nest)\n  female.list <- as.list(NA)  \n  # lists and vectors used within the function\n  list.threshold <- as.list(NA)\n  vector.days <- as.vector(NA)  \n  # final list to store all the data frame that the function returns\n  incubation.list <- as.list(NA)\n  \n  # splits data by date\n  list.day <- split (data, data$date)\n  \n  # selects the defined night time window\n  if (lower.time < 24 && lower.time < upper.time) {\n    subset.data <- data [data$dec.time > lower.time & data$dec.time < upper.time, ]\n    subset.list <- split (subset.data, subset.data$date)\n    \n  } else {\n    if (lower.time < 24 && lower.time > upper.time) {\n      # night period\n      subset.nightBefore <- data [data$dec.time > lower.time & data$dec.time < 24, ]\n      ## matching night periods with next day's morning\n      subset.nightBefore$effec.date <- subset.nightBefore$date + 1\n      \n      # day period\n      subset.morning <- data [data$dec.time > 0 & data$dec.time < upper.time, ]\n      ## replicating new date column\n      subset.morning$effec.date <- subset.morning$date\n      \n      # combining both periods\n      subset.data <- rbind(subset.nightBefore, subset.morning)\n      \n      \n      # splitting by effec.date\n      subset.list <- split (subset.data, subset.data$effec.date)\n      \n    } \n  }\n  # \n  # FUNCTION ITSELF - THROUGH DAY LOOPS\n  #\n  # loop to analyse each day separately\n  for (d in 1:length(list.day)) {\n    data.day <- list.day [[d]]\n    \n    # if there is no night ref for any day, then warning message and jump\n    # to next day\n    if (sort(names (subset.list)==as.character(unique(data.day$date)),\n             decreasing=TRUE)[1]==TRUE) {\n      subset.night <-  subset.list[[as.character(unique(data.day$date))]]\n    } else {\n      warning(paste(\"No night reference period for \",\n                    as.character(unique(data.day$date)), \n                    \" - day skipped\"))\n      old.leaving.threshold <- NA\n      old.entering.threshold <- NA\n      final.leaving.threshold <- NA\n      final.entering.threshold <- NA\n      night_day_varRatio <- NA\n      list.threshold[[d]] <- c(as.character(unique (data.day$date)), \n                               old.entering.threshold, \n                               final.entering.threshold,\n                               old.leaving.threshold, \n                               final.leaving.threshold, \n                               night_day_varRatio)\n      next()\n    }\n    \n    # checking for night variation\n    # if much variation, then the night is not used\n    night.drop <- min (subset.night$temp1, na.rm=TRUE)       # super off-bout\n    night.raise <- max (subset.night$temp1, na.rm=TRUE)      # super on-bout\n    if (night.drop <= -maxNightVar_accepted ||\n        night.raise >= +maxNightVar_accepted) {\n      warning (paste(\"Night variation on \", paste(\n        as.character(unique(subset.night$date)[1]),\n        as.character(unique(subset.night$date)[2]), sep=\"/\"),\n        \" has passed set limit\"))\n      \n      if (d==1) {\n        warning (paste (\"Night drop limit exit on \", paste(\n          as.character(unique(subset.night$date)[1]),\n          as.character(unique(subset.night$date)[2]), sep=\"/\"),\n          \" and no previous night as reference. Day not analysed.\"))\n        old.entering.threshold <- NA\n        old.leaving.threshold <- NA\n        final.entering.threshold <- NA\n        final.leaving.threshold <- NA \n        night_day_varRatio <-  NA\n        list.threshold[[d]] <- c(as.character(unique (data.day$date)), \n                                 old.entering.threshold, \n                                 final.entering.threshold,\n                                 old.leaving.threshold, \n                                 final.leaving.threshold, \n                                 night_day_varRatio)\n        next()\n      } else {\n        old.entering.threshold <- max (subset.night$temp1, na.rm=TRUE)\n        old.leaving.threshold <- min (subset.night$temp1, na.rm=TRUE)\n        if (is.na(list.threshold[[d-1]][3]) || is.na(list.threshold[[d-1]][5])){\n          warning (paste (\"Night drop limit exit on \", paste(\n            as.character(unique(subset.night$date)[1]),\n            as.character(unique(subset.night$date)[2]), sep=\"/\"),\n            \" and no previous night as reference. Day not analysed.\"))\n          final.entering.threshold <- NA\n          final.leaving.threshold <- NA \n          night_day_varRatio <-  var (subset.night$temp1, na.rm=TRUE) / \n            var(data.day$temp1[data.day$dec.time>11 & data.day$dec.time<15], na.rm=TRUE)\n          list.threshold[[d]] <- c(as.character(unique (data.day$date)), \n                                   old.entering.threshold, \n                                   final.entering.threshold,\n                                   old.leaving.threshold, \n                                   final.leaving.threshold, \n                                   night_day_varRatio)\n          next()\n        } else {\n          final.entering.threshold <- as.numeric(list.threshold[[d-1]][3])\n          final.leaving.threshold <- as.numeric(list.threshold[[d-1]][5])\n          night_day_varRatio <-  var (subset.night$temp1, na.rm=TRUE) / \n            var(data.day$temp1[data.day$dec.time>11 & data.day$dec.time<15], na.rm=TRUE)\n        }\n      }\n    } else {\n      # maximum/minimum change in temperature at \"night\"\n      old.entering.threshold <- NA\n      old.leaving.threshold <- NA\n      final.entering.threshold <- max (subset.night$temp1, na.rm=TRUE)\n      final.leaving.threshold <- min (subset.night$temp1, na.rm=TRUE)\n      night_day_varRatio <-  var (subset.night$temp1, na.rm=TRUE) / \n        var(data.day$temp1[data.day$dec.time>11 & data.day$dec.time<15], na.rm=TRUE)\n    }\n    \n    # storing data\n    list.threshold[[d]] <- c(as.character(unique (data.day$date)), \n                             old.entering.threshold, \n                             final.entering.threshold,\n                             old.leaving.threshold, \n                             final.leaving.threshold, \n                             night_day_varRatio)\n    \n    # assessment of differential temperature\n    for (i in 2:length(data.day$temp1)) {\n      \n      data.day$leaving[1] <- 0\n      data.day$entering[1] <- 1\n      \n      # distance from nest temperature to env.temperature\n      if (is.na(data.day$valueT[i])) {next()}\n      # is there environmental data?\n      if (env.data==TRUE) {\n        statement <-  (data.day$valueT[i] - data.day$env.temp[i]) < time.dif\n      } else {\n        if (MAX.T==NULL) {stop (\"No maximum temperature assigned\")\n        } else {\n          statement <-  (MAX.T - data.day$valueT[i]) > time.dif\n        }\n      }\n      # now the evaluation of statement\n      if (statement) {\n        correction.min <- sensitivity\n        correction.max <- 1\n      } else {\n        correction.min <- 1\n        correction.max <- 0\n      }\n      \n      # sorting of off-bouts\n      if (is.na(data.day$temp1[i])) {next()}\n      if (data.day$temp1[i] < final.leaving.threshold*correction.min) {\n        data.day$leaving[i] <- 1\n      } else {\n        data.day$leaving[i] <- 0\n      }\n      \n      # sorting of on-bouts\n      if (data.day$temp1[i] > (final.entering.threshold*correction.max)) {\n        data.day$entering[i] <- 1\n      } else {\n        data.day$entering[i] <- 0\n      }\n    }\n    \n    # variables for loop\n    data.day$inc.vector <- NA\n    seq.loop <- 1\n    \n    # data set for further loops; they select \"leaving\" and \"entering\" events\n    data.leaving <- data.day[data.day$leaving==1,]\n    data.entering <- data.day[data.day$entering==1,]\n    \n    # if female did not leave, then always in\n    if (nrow(data.leaving)==0) {\n      data.day$inc.vector <- 1\n      next()\n    }\n    \n    #\n    # based on when the female left and entered the nest, a vector of the\n    # presence of the female in the nest can be created\n    #\n    #big loop for clasification\n    for (j in 1:length(data.day$entering)) {\n      \n      # only loop through especial cases\n      if (j != tail(seq.loop, 1)) {next()}\n      # filling the gaps\n      if (data.day$entering[j]==1) {\n        index.dif <- data.leaving$index - data.day$index[j]\n        \n        # if there's no more changes ahead, fill and stop\n        if (max(index.dif)<=0) {\n          data.day$inc.vector[j:length(data.day$entering)] <- 1\n          break ()\n        }\n        # gap to fill\n        addition <- min(index.dif [index.dif > 0])\n        new.index <-  j +  addition\n        \n        # filling 1's when female is in\n        data.day$inc.vector [(j):(new.index-1)] <- 1\n        \n        # new loop step\n        seq.loop <- c(seq.loop, tail(seq.loop, 1)+addition)\n        \n      } else {\n        # repetition for off-bout times\n        if (data.day$leaving[j]==1) {\n          index.dif <- data.entering$index - data.day$index[j]\n          \n          # stop when at the end of the vector\n          if (max(index.dif)<=0) {\n            data.day$inc.vector[j:length(data.day$entering)] <- 0\n            break ()\n          }\n          # gap to fill\n          addition <- min(index.dif [index.dif > 0])\n          new.index <-  j + addition\n          \n          # filling 0's when female is not in\n          data.day$inc.vector [j:(new.index-1)] <- 0\n          \n          # new loop step\n          seq.loop <- c(seq.loop, tail(seq.loop, 1)+addition)\n        }\n      }\n    }\n    \n    # compiling list\n    female.list[[d]] <- data.day\n  }\n  # data with the new vector for in/out female\n  final.data <- do.call(\"rbind\",female.list)\n  incubation.list[[1]] <-  final.data\n  \n  final.threshold <- as.data.frame(do.call(\"rbind\",list.threshold))\n  names(final.threshold) <- c(\"date\", \n                              \"old.entering.threshold\", \n                              \"final.entering.threshold\",\n                              \"old.leaving.threshold\", \"final.leaving.threshold\", \n                              \"night_day_varRatio\")\n  incubation.list[[2]] <- final.threshold[complete.cases(final.threshold$date),]\n  incubation.list[[2]]$year <- unique (data[[\"year\"]])\n  \n  return(incubation.list)\n}\n",
    "created" : 1461151589747.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "53|51|57|2|\n58|53|76|4|\n",
    "hash" : "506387472",
    "id" : "D09CEDB3",
    "lastKnownWriteTime" : 1461152363,
    "path" : "D:/R development/incR/R/incR_scan.r",
    "project_path" : "R/incR_scan.r",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}